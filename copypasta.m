Y := $1;
SingularPoints(Y);
SingularPointsOverSplittingField(Y);
Genus(Y);
ArithmeticGenus(Y);
IsAffine(Y);
ProjectiveClosure(Y);
SingularPoints($1);
ProjectiveMap(x1);
Y;
Y.1;
ProjectiveMap(Y.1);
Degree(Y.1);
Y.2;
Degree($1);
hom< Y -> X | Y.1>;
map< Y -> X | Y.1>;
map< Y -> X | [Y.1,1]>;
phi2 := $1;
Degree(phi2);
Ybar := ProjectiveClosure(Y);
Ybar.1;
Ybar;
map< Ybar -> | [Ybar.1, Ybar.3]>;
map< Ybar -> X | [Ybar.1, Ybar.3]>;
phi2 := $1;
Degree(phi2);
phi2*phi;
phi*phi2;
ProjectiveMap(phi);
phi_map := $1;
phi_map*phi2;
phi2*phi_map;
phi_new := $1;
Degree(phi_new);
MonodromyGroup;
MonodromyRepresentation;
Ybar;
Y0 := Y;
Y := Ybar;
KY<y1,y2> := FunctionField(Y);
GaloisGroup(KY);
MonodromyGroup(KY);
GaloisClosure(KY);
GaloisGroup;
GaloisRepresentation;
Y;
phi_new;
DefiningEquations(phi_new);
Parent($1[1]);
DefiningEquations(phi_new);
eqns := $1;
R;
R := Parent(eqns[1]);
I := ideal< R | eqns>;
eqns_aff := [Evaluate(el, [R.1, R.2, 1]) : el in eqns];
eqns_aff;
S<t1,t2> := Parent($1[1]);
I := ideal< S | eqns_aff>;
I;
EliminationIdeal(I, [t1]);
EliminationIdeal(I, {t1});
EliminationIdeal(I, {t2});
